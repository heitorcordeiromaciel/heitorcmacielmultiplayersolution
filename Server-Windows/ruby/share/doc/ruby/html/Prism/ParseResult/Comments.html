<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>class Prism::ParseResult::Comments - Documentation for Ruby 3.4</title>

  <meta name="keywords" content="ruby,class,Prism::ParseResult::Comments">

    <meta name="description" content="class Prism::ParseResult::Comments: When we&#39;ve parsed the source, we have both the syntax tree and the list of comments that we found in the source. This class is responsible for walking">


<link rel="canonical" href="https://docs.ruby-lang.org/en/3.4/Prism/ParseResult/Comments.html">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
  <div id="parent-class-section" class="nav-section">
  <h3>Ancestors</h3>
  <ul><li><a href="../../Object.html">Object</a><ul><li><a href="../../BasicObject.html">BasicObject</a></li></ul></li></ul>
</div>

  
  
  
  <div class="nav-section">
    <h3>Class Methods</h3>
    <ul class="link-list" role="directory">
      <li ><a href="#method-c-new">new</a></li>
    </ul>
  </div>



  <div class="nav-section">
    <h3>Instance Methods</h3>
    <ul class="link-list" role="directory">
      <li ><a href="#method-i-attach-21">attach!</a></li>
      <li ><a href="#method-i-nearest_targets">nearest_targets</a></li>
    </ul>
  </div>



  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.14.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-labelledby="class-Prism::ParseResult::Comments">
  
  
    <ol role="navigation" aria-label="breadcrumb" class="breadcrumb">
      
      <li>
        
        <a href="../../Prism.html">Prism</a><span>::</span>
        
      </li>
      
      <li>
        
        <a href="../../Prism/ParseResult.html">ParseResult</a><span>::</span>
        
      </li>
      
      <li>
        
        <span>Comments</span>
        
      </li>
      
    </ol>
  

  <h1 id="class-Prism::ParseResult::Comments" class="anchor-link class">
    class Prism::ParseResult::Comments
  </h1>

  <section class="description">
    
<p>When we’ve parsed the source, we have both the syntax tree and the list of comments that we found in the source. This class is responsible for walking the tree and finding the nearest location to attach each comment.</p>

<p>It does this by first finding the nearest locations to each comment. Locations can either come from nodes directly or from location fields on nodes. For example, a <a href="../ClassNode.html"><code>ClassNode</code></a> has an overall location encompassing the entire class, but it also has a location for the <code>class</code> keyword.</p>

<p>Once the nearest locations are found, it determines which one to attach to. If it’s a trailing comment (a comment on the same line as other source code), it will favor attaching to the nearest location that occurs before the comment. Otherwise it will favor attaching to the nearest location that is after the comment.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section anchor-link">



    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      <div id="attribute-i-parse_result" class="method-detail anchor-link">
        <div class="method-heading attribute-method-heading">
          <a href="#attribute-i-parse_result" title="Link to this attribute">
            <span class="method-name">parse_result</span>
            <span class="attribute-access-type">[R]</span>
          </a>
        </div>

        <div class="method-description">
        <p>The parse result that we are attaching comments to.</p>
        </div>
      </div>
    </section>


     <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail anchor-link ">
        <div class="method-header">
            <div class="method-heading">
              <a href="#method-c-new" title="Link to this method">
                <span class="method-name">new</span>
                <span class="method-args">(parse_result)</span>
              </a>
            </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/prism/parse_result/comments.rb, line 87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">parse_result</span>)
  <span class="ruby-ivar">@parse_result</span> = <span class="ruby-identifier">parse_result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Create a new <a href="Comments.html"><code>Comments</code></a> object that will attach comments to the given parse result.</p>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-attach-21" class="method-detail anchor-link ">
        <div class="method-header">
            <div class="method-heading">
              <a href="#method-i-attach-21" title="Link to this method">
                <span class="method-name">attach!</span>
                <span class="method-args">()</span>
              </a>
            </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="attach-21-source">
            <pre><span class="ruby-comment"># File lib/prism/parse_result/comments.rb, line 93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attach!</span>
  <span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">preceding</span>, <span class="ruby-identifier">enclosing</span>, <span class="ruby-identifier">following</span> = <span class="ruby-identifier">nearest_targets</span>(<span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">comment</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">trailing?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">preceding</span>
        <span class="ruby-identifier">preceding</span>.<span class="ruby-identifier">trailing_comment</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-keyword">else</span>
        (<span class="ruby-identifier">following</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">enclosing</span> <span class="ruby-operator">||</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">value</span>)).<span class="ruby-identifier">leading_comment</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># If a comment exists on its own line, prefer a leading comment.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">following</span>
        <span class="ruby-identifier">following</span>.<span class="ruby-identifier">leading_comment</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">preceding</span>
        <span class="ruby-identifier">preceding</span>.<span class="ruby-identifier">trailing_comment</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-keyword">else</span>
        (<span class="ruby-identifier">enclosing</span> <span class="ruby-operator">||</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">value</span>)).<span class="ruby-identifier">leading_comment</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Attach the comments to their respective locations in the tree by mutating the parse result.</p>
        </div>


      </div>

    </section>

     <section id="private-instance-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

      <div id="method-i-nearest_targets" class="method-detail anchor-link ">
        <div class="method-header">
            <div class="method-heading">
              <a href="#method-i-nearest_targets" title="Link to this method">
                <span class="method-name">nearest_targets</span>
                <span class="method-args">(node, comment)</span>
              </a>
            </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="nearest_targets-source">
            <pre><span class="ruby-comment"># File lib/prism/parse_result/comments.rb, line 120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nearest_targets</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">comment</span>)
  <span class="ruby-identifier">comment_start</span> = <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">start_offset</span>
  <span class="ruby-identifier">comment_end</span> = <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">end_offset</span>

  <span class="ruby-identifier">targets</span> = [] <span class="ruby-comment">#: Array[_Target]</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">comment_targets</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">value</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">StatementsNode</span>
      <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">value</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">node</span>) })
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Node</span>
      <span class="ruby-identifier">targets</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Location</span>
      <span class="ruby-identifier">targets</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">LocationTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">sort_by!</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:start_offset</span>)
  <span class="ruby-identifier">preceding</span> = <span class="ruby-keyword">nil</span> <span class="ruby-comment">#: _Target?</span>
  <span class="ruby-identifier">following</span> = <span class="ruby-keyword">nil</span> <span class="ruby-comment">#: _Target?</span>

  <span class="ruby-identifier">left</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">right</span> = <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">length</span>

  <span class="ruby-comment"># This is a custom binary search that finds the nearest nodes to the</span>
  <span class="ruby-comment"># given comment. When it finds a node that completely encapsulates the</span>
  <span class="ruby-comment"># comment, it recurses downward into the tree.</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">right</span>
    <span class="ruby-identifier">middle</span> = (<span class="ruby-identifier">left</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">right</span>) <span class="ruby-operator">/</span> <span class="ruby-value">2</span>
    <span class="ruby-identifier">target</span> = <span class="ruby-identifier">targets</span>[<span class="ruby-identifier">middle</span>]

    <span class="ruby-identifier">target_start</span> = <span class="ruby-identifier">target</span>.<span class="ruby-identifier">start_offset</span>
    <span class="ruby-identifier">target_end</span> = <span class="ruby-identifier">target</span>.<span class="ruby-identifier">end_offset</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">target</span>.<span class="ruby-identifier">encloses?</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-comment"># @type var target: NodeTarget</span>
      <span class="ruby-comment"># The comment is completely contained by this target. Abandon the</span>
      <span class="ruby-comment"># binary search at this level.</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">nearest_targets</span>(<span class="ruby-identifier">target</span>.<span class="ruby-identifier">node</span>, <span class="ruby-identifier">comment</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">target_end</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">comment_start</span>
      <span class="ruby-comment"># This target falls completely before the comment. Because we will</span>
      <span class="ruby-comment"># never consider this target or any targets before it again, this</span>
      <span class="ruby-comment"># target must be the closest preceding target we have encountered so</span>
      <span class="ruby-comment"># far.</span>
      <span class="ruby-identifier">preceding</span> = <span class="ruby-identifier">target</span>
      <span class="ruby-identifier">left</span> = <span class="ruby-identifier">middle</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">comment_end</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">target_start</span>
      <span class="ruby-comment"># This target falls completely after the comment. Because we will</span>
      <span class="ruby-comment"># never consider this target or any targets after it again, this</span>
      <span class="ruby-comment"># target must be the closest following target we have encountered so</span>
      <span class="ruby-comment"># far.</span>
      <span class="ruby-identifier">following</span> = <span class="ruby-identifier">target</span>
      <span class="ruby-identifier">right</span> = <span class="ruby-identifier">middle</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># This should only happen if there is a bug in this parser.</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Comment location overlaps with a target location&quot;</span>
  <span class="ruby-keyword">end</span>

  [<span class="ruby-identifier">preceding</span>, <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">node</span>), <span class="ruby-identifier">following</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Responsible for finding the nearest targets to the given comment within the context of the given encapsulating node.</p>
        </div>


      </div>

    </section>

  </section>
</main>

